package com.polycraft.engine.scripting;

import com.polycraft.engine.PolyCraftEngine;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Handles loading scripts and their dependencies.
 */
public class ScriptLoader {
    
    private static final Pattern REQUIRE_PATTERN = Pattern.compile("//\s*@require\s+([^\s]+)");
    private static final String SCRIPT_HEADER = "// Auto-generated by PolyCraft Engine - Do not edit!\n";
    
    private final PolyCraftEngine plugin;
    private final File scriptsFolder;
    private final File libsFolder;
    
    public ScriptLoader(PolyCraftEngine plugin) {
        this.plugin = plugin;
        this.scriptsFolder = new File(plugin.getDataFolder(), "scripts");
        this.libsFolder = new File(plugin.getDataFolder(), "libs");
        
        // Create directories if they don't exist
        if (!scriptsFolder.exists()) {
            scriptsFolder.mkdirs();
        }
        if (!libsFolder.exists()) {
            libsFolder.mkdirs();
        }
    }
    
    /**
     * Load a script file and its dependencies.
     * @param scriptFile The script file to load
     * @return The loaded script content with dependencies
     * @throws IOException If there's an error reading the script or its dependencies
     */
    public String loadScript(File scriptFile) throws IOException {
        if (!scriptFile.exists()) {
            throw new IOException("Script file not found: " + scriptFile.getPath());
        }
        
        // Read the script content
        String content = new String(
            java.nio.file.Files.readAllBytes(scriptFile.toPath()),
            StandardCharsets.UTF_8
        );
        
        // Process requires
        Set<String> loadedDeps = new HashSet<>();
        StringBuilder result = new StringBuilder(SCRIPT_HEADER);
        
        // Add script directory to the result
        result.append("// Script: ").append(scriptFile.getName()).append("\n\n");
        
        // Process dependencies
        processDependencies(scriptFile.getParentFile(), content, loadedDeps, result);
        
        // Add the main script content
        result.append("\n// Main script content\n");
        result.append(stripRequires(content));
        
        return result.toString();
    }
    
    /**
     * Process all dependencies of a script.
     */
    private void processDependencies(File baseDir, String content, Set<String> loadedDeps, StringBuilder result) {
        Matcher matcher = REQUIRE_PATTERN.matcher(content);
        
        while (matcher.find()) {
            String depName = matcher.group(1);
            
            // Skip if already loaded
            if (loadedDeps.contains(depName)) {
                continue;
            }
            
            try {
                // Try to find the dependency
                File depFile = findDependency(baseDir, depName);
                if (depFile != null && depFile.exists()) {
                    // Mark as loaded
                    loadedDeps.add(depName);
                    
                    // Load the dependency content
                    String depContent = new String(
                        java.nio.file.Files.readAllBytes(depFile.toPath()),
                        StandardCharsets.UTF_8
                    );
                    
                    // Process nested dependencies
                    processDependencies(depFile.getParentFile(), depContent, loadedDeps, result);
                    
                    // Add the dependency content
                    result.append("\n// Dependency: ").append(depName).append("\n");
                    result.append(stripRequires(depContent));
                    result.append("\n");
                } else {
                    plugin.getLogger().warning("Dependency not found: " + depName);
                }
            } catch (Exception e) {
                plugin.getLogger().log(Level.WARNING, "Error loading dependency: " + depName, e);
            }
        }
    }
    
    /**
     * Find a dependency file in the script's directory or the libs folder.
     * @param baseDir The base directory to search in
     * @param depName The dependency name or path
     * @return The dependency file, or null if not found
     */
    File findDependency(File baseDir, String depName) {
        // Check if it's a direct file path
        File depFile = new File(baseDir, depName);
        if (depFile.exists()) {
            return depFile;
        }
        
        // Check in the libs folder
        depFile = new File(libsFolder, depName);
        if (depFile.exists()) {
            return depFile;
        }
        
        // Check with .js extension if no extension is provided
        if (!depName.contains(".")) {
            depFile = new File(baseDir, depName + ".js");
            if (depFile.exists()) {
                return depFile;
            }
            
            depFile = new File(libsFolder, depName + ".js");
            if (depFile.exists()) {
                return depFile;
            }
        }
        
        return null;
    }
    
    /**
     * Find a dependency file in the script's directory or the libs folder.
     * This is a package-private method to be used by other classes in the same package.
     * @param baseDir The base directory to search in
     * @param depName The dependency name or path
     * @return The dependency file, or null if not found
     */
    File findDependencyPackage(File baseDir, String depName) {
        return findDependency(baseDir, depName);
    }
    
    /**
     * Strip require statements from the script content.
     */
    private String stripRequires(String content) {
        return content.replaceAll(REQUIRE_PATTERN.pattern(), "");
    }
    
    /**
     * Get the scripts folder.
     */
    public File getScriptsFolder() {
        return scriptsFolder;
    }
    
    /**
     * Get the libs folder.
     */
    public File getLibsFolder() {
        return libsFolder;
    }
    
    /**
     * Get all script files in the scripts folder.
     */
    public List<File> listScripts() {
        File[] files = scriptsFolder.listFiles((dir, name) -> {
            String lower = name.toLowerCase();
            return lower.endsWith(".js") || lower.endsWith(".py") || lower.endsWith(".rb");
        });
        
        return files != null ? Arrays.asList(files) : Collections.emptyList();
    }
    
    /**
     * Get the script configuration for a script file.
     */
    public ScriptConfig getScriptConfig(File scriptFile) {
        File configFile = new File(scriptFile.getParentFile(), scriptFile.getName() + ".yml");
        if (!configFile.exists()) {
            return null;
        }
        
        try {
            FileConfiguration config = YamlConfiguration.loadConfiguration(configFile);
            return new ScriptConfig(config);
        } catch (Exception e) {
            plugin.getLogger().log(Level.WARNING, "Error loading script config: " + configFile.getName(), e);
            return null;
        }
    }
    
    /**
     * Represents a script's configuration.
     */
    public static class ScriptConfig {
        private final FileConfiguration config;
        
        public ScriptConfig(FileConfiguration config) {
            this.config = config;
        }
        
        public String getName() {
            return config.getString("name", "");
        }
        
        public String getVersion() {
            return config.getString("version", "1.0.0");
        }
        
        public String getDescription() {
            return config.getString("description", "");
        }
        
        public String getAuthor() {
            return config.getString("author", "");
        }
        
        public List<String> getDependencies() {
            return config.getStringList("dependencies");
        }
        
        public boolean isEnabled() {
            return config.getBoolean("enabled", true);
        }
    }
}
